1. * Напишите список операций, которые вы будете производить для остановки запроса пользователя:<br/>
найдём все операции в базе db1 которые длятся более 3 секунд<br/>
db.currentOp(<br/>
&ensp;   {<br/>
&emsp; &emsp;  "active" : true,<br/>
&emsp; &emsp;  "secs_running" : { "$gt" : 3 },<br/>
&emsp; &emsp;  "ns" : /^db1\./<br/>
&emsp; &emsp;  }<br/>
)<br/>

     затем можно прервать необходимую операцию по её ID используя метод db.killOp().<br/>
* предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB:<br/>
для контроля над временем выполнения операций можно использовать метод maxTimeMS()<br/>

2. Если в БД появилось очень много истекающих ключей в одну и ту же секунду и они составляют по крайней мере 25% от всех текущих ключей с установленным сроком действия, Redis может заблокировать запись чтобы процент просроченных ключей был ниже 25%<br/>
3. Иногда потеря соединения с сообщением “during query” происходит когда миллионы строк были посланы как часть одного или нескольких запросов. Если нам это известно требуется увеличить net_read_timeout с 30 секунд по умолчанию до 60 секунд или больше, чтобы этого времени хватало для завершения передачи.<br/>
Реже такое событие происходит, когда клиент пытается инициировать соединение к серверу. В этом случае connect_timeout можно установить 10 секунд или более если расстояние очень большое или соединение медленное.<br/>
4. Out-Of-Memory Killer это механизм уровня ОС, предназначен для освобождения памяти путём прекращения процессов с низким приоритетом. Когда оперативная память исчерпана задействуется OOM killer и он может прекратить процесс PostgreSQL. 
Требуется проверить настройки памяти исходя из используемого оборудования.
В Linux можно включать и отключать OOM-Killer (не рекомендуется).  
Linux может зарезервировать для процессов больше памяти, чем есть, но не выделять ее по факту, и этим поведением управляет параметр ядра Linux. За это отвечает переменная vm.overcommit_memory.